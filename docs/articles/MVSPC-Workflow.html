<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multivariate Statistical Process Control with mvMonitoring • mvMonitoring</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">mvMonitoring</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/MVSPC-Workflow.html">Multivariate Statistical Process Control with mvMonitoring</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/gabrielodom/mvMonitoring">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Multivariate Statistical Process Control with mvMonitoring</h1>
                        <h4 class="author">Gabriel Odom</h4>
            
            <h4 class="date">2017-11-03</h4>
          </div>

    
    
<div class="contents">
<p>This document serves to introduce engineers to the workflow necessary to follow in order to analyze multivariate process monitoring data via the <code>mvMonitoring</code> package.</p>
<p><br><br></p>
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction </h1>
<p>This is the accompanying package to the research published by <a href="https://link.springer.com/article/10.1007/s00477-016-1246-2">Kazor et al (2016)</a> and forthcoming paper by <a href="https://www.overleaf.com/read/vbfbjsywtkvv#/26878504/">Odom et al (2017)</a> (manuscript in progress). The <code>mvMonitoring</code> package is designed to make simulation of multi-state multivariate process monitoring statistics easy and straightforward, as well as streamlining the online process monitoring component.</p>
</div>
<div id="motivation" class="section level1">
<h1 class="hasAnchor">
<a href="#motivation" class="anchor"></a>Motivation </h1>
<div id="why-use-mvmonitoring" class="section level2">
<h2 class="hasAnchor">
<a href="#why-use-mvmonitoring" class="anchor"></a>Why use <code>mvMonitoring</code>
</h2>
<p>The <code>mvMonitoring</code> package can be used to detect outliers in a correlated multivariate process with non-linear, non-stationary, or autocorrelated feature behavior. These process outliers are often indicative of system fault. The common and naive approach to multivariate process monitoring is to use expert opinion to identify a few important features to monitor visually, and raise an alarm if these features travel outside pre-defined normal operating boundaries.</p>
<p>However, this split univariate approach fails to account for the correlated nature of the process features, so some engineers have taken to monitoring the system as a single correlated multivariate process rather than a collection of independent univaraite processes. In the literature review of the motivating papers, the authors cite how this approach has benefitted the science of process monitoring as a whole. Unfortunately, this approach has its own shortcomings – namely, montioring a multivariate process in its original feature space can lead to exorbitant computational costs.</p>
<p>To this end, <em>principal components analysis</em> (PCA) and its many modifications have been employed to reduce the computation necessary to monitor a multivariate process as a whole. This package is an implementation of one such PCA modification.</p>
</div>
<div id="multi--or-single-state-ad-pca" class="section level2">
<h2 class="hasAnchor">
<a href="#multi--or-single-state-ad-pca" class="anchor"></a>Multi- or Single-State AD-PCA</h2>
<p>AD-PCA is <em>adaptive-dynamic</em> PCA, which accounts for non-linearity, non-stationarity, and autocorrelation in the multivariate process, and this modification is thoroghly discussed in Kazor et al (2016).</p>
<dl>
<dt>Multi-State Monitoring</dt>
<dd>a modification of PCA which accounts for multiple process states and models them seperately. States can be any mutually exclusive blocking factor, and states do not necessarily follow a strict order.
</dd>
</dl>
<p>Multi-State AD-PCA (MSAD-PCA) allows process engineers to account for a few very different process states. Specifically, this modification should be used when features under different process states have different means, correlations, or variances.</p>
<p><br><br></p>
</div>
</div>
<div id="the-msp-functions" class="section level1">
<h1 class="hasAnchor">
<a href="#the-msp-functions" class="anchor"></a>The <code>msp</code> Functions</h1>
<p>These are brief descriptions of the external functions useful for multivariate statistical process monitoring via MSAD- or AD-PCA.</p>
<div id="simulating-data-with-mspprocessdata" class="section level2">
<h2 class="hasAnchor">
<a href="#simulating-data-with-mspprocessdata" class="anchor"></a>Simulating Data with <code>mspProcessData</code>
</h2>
<p>This function generates three-dimensional multi-state or single-state non-linear, non-stationary, and autocorrelated process observations. We follow the seminal work of <a href="http://onlinelibrary.wiley.com/doi/10.1002/aic.690420810/abstract">Dong and McAvoy (1996)</a> for generation of the foundational stationary and independent features.</p>
<div id="latent-feature-creation" class="section level3">
<h3 class="hasAnchor">
<a href="#latent-feature-creation" class="anchor"></a>Latent Feature Creation</h3>
<p>So that the simulated features have non-zero correlations, Dong and McAvoy created their three features all as polynomial functions of a single latent variable <span class="math inline">\(t(s)\)</span>, where <span class="math inline">\(s = 1, \ldots, \omega\)</span> is the observational index of the process.</p>
<div id="autocorrelated-and-non-stationary-error" class="section level4">
<h4 class="hasAnchor">
<a href="#autocorrelated-and-non-stationary-error" class="anchor"></a>Autocorrelated and Non-Stationary Error</h4>
<p>The <code>mspProcesData</code> function induces autocorrelation in <span class="math inline">\(t\)</span> through its errors, <span class="math inline">\(\varepsilon_s\)</span>, where <span class="math display">\[
\varepsilon_1 \sim \mathcal{N}\left(\frac{1}{2}(a + b)(1 - \phi), \frac{b - a}{12} (1 - \phi ^ 2)\right),
\]</span> where <span class="math inline">\(a = 0.01\)</span> and <span class="math inline">\(b = 2\)</span>. Now, we define the first-order autoregressive process on <span class="math inline">\(\varepsilon_s\)</span> by <span class="math display">\[
\varepsilon_s = \varphi\varepsilon_{s - 1} + (1 - \varphi)\varepsilon,
\]</span> where <span class="math inline">\(\varepsilon\)</span> is as defined in the previous expression and the autocorrelation component <span class="math inline">\(\phi = 0.75\)</span>. The mean and variance multipliers are the mean and variance of a random variable from the <span class="math inline">\(\mathcal{U}_{[a,b]}\)</span> distribution.</p>
</div>
<div id="the-non-linear-latent-process" class="section level4">
<h4 class="hasAnchor">
<a href="#the-non-linear-latent-process" class="anchor"></a>The Non-Linear Latent Process</h4>
<p>This <span class="math inline">\(t\)</span> vector will be sinusoidal with period <span class="math inline">\(\omega = 7 * 24 * 60\)</span> (signifying a weekly period in minute-level observations). We then synthesize a <span class="math inline">\(t\)</span> with <span class="math display">\[
t^*_s = -\cos\left( \frac{2\pi}{\omega} s \right) + \epsilon_s,
\]</span> and scale <span class="math inline">\(t^*\)</span> to <span class="math display">\[
t = \frac{(b - a)(t^*_s - \text{min}(t^*_s))}{\text{max}(t^*_s) - \text{min}(t^*_s)} + a.
\]</span> Finally then, the <span class="math inline">\(t\)</span> vector will lie entirely in <span class="math inline">\([a,b]\)</span>.</p>
</div>
</div>
<div id="single-state-and-multi-state-features" class="section level3">
<h3 class="hasAnchor">
<a href="#single-state-and-multi-state-features" class="anchor"></a>Single-State and Multi-State Features</h3>
<div id="single-state-features" class="section level4">
<h4 class="hasAnchor">
<a href="#single-state-features" class="anchor"></a>Single State Features</h4>
First <code>mspProcessData</code> simulates three features, with each feaure operating under <span class="math inline">\(k\)</span> different states. Let <span class="math inline">\(&lt;x_k(t), y_k(t), z_k(t)&gt;\)</span> be the notation for State <span class="math inline">\(k\)</span>. These are the three features under State 1 (normal operating conditions, or <em>NOC</em>) as three functions of <span class="math inline">\(t\)</span>:
<span class="math display">\[\begin{align}
  \textbf{x}(\textbf{t}) &amp;\equiv \textbf{t} + \boldsymbol\varepsilon_1, \\
  \textbf{y}(\textbf{t}) &amp;\equiv \textbf{t} ^ 2 - 3 * \textbf{t} + \boldsymbol\varepsilon_2, \\
  \textbf{z}(\textbf{t}) &amp;\equiv -\textbf{t} ^ 3 + 3 * \textbf{t} ^ 2 + \boldsymbol\varepsilon_3,
\end{align}\]</span>
<p>where <span class="math inline">\(\varepsilon_i \sim N(0, 0.01)\)</span>. The <code>mspProcessData</code> function calls the internal <code>processNOCdata</code> function to generate single-state observations under normal operating conditions (NOC).</p>
</div>
<div id="multi-state-features" class="section level4">
<h4 class="hasAnchor">
<a href="#multi-state-features" class="anchor"></a>Multi-State Features</h4>
<p>The multi-state feature expression is induced by rotation and scaling of certain sets of observations. To induce a three-state, hourly switching process (the default), the <code>mspProcessData</code> function will create a label column that switches from “1” to “2” to “3” every hour. State “1” will be the features generated under the single-state assumption, while State “2” and State “3” are generated as follows. These states will be scaled rotations of the current <span class="math inline">\(&lt;x,y,z&gt;\)</span> set. The second state is yaw, pitch, and roll rotated by (0, 90, 30) degrees, and the scales are multiplied by (1, 0.5, 2). The third state is yaw, pitch, and roll rotated by (90, 0, -30) degrees, and the scales are multiplied by (0.25, 0.1, 0.75).</p>
<ul>
<li><p><span class="math inline">\(\mathcal{S}_1\)</span>: <span class="math inline">\(\textbf{X}(t_s) := \langle x(t_s), y(t_s), z(t_s)\rangle\)</span>.</p></li>
<li><p><span class="math inline">\(\mathcal{S}_2\)</span>: <span class="math inline">\(\textbf{X}(t_s) := \langle x(t_s), y(t_s), z(t_s)\rangle \cdot \textbf{P}_1\boldsymbol\Lambda_1\)</span>, where <span class="math display">\[
\textbf{P}_1 = \begin{bmatrix}
 0    &amp;  0.50 &amp; -0.87 \\
 0    &amp;  0.87 &amp;  0.50 \\
 1    &amp;  0    &amp;  0   
\end{bmatrix}
\]</span> is the orthogonal rotation matrix for a yaw, pitch and roll degree change of <span class="math inline">\(\langle 0^{\circ}, 90^{\circ}, 30^{\circ} \rangle\)</span>, and <span class="math inline">\(\boldsymbol\Lambda_1 = \text{diag}(1, 0.5, 2)\)</span> is a diagonal scaling matrix.</p></li>
<li><p><span class="math inline">\(\mathcal{S}_3\)</span>: <span class="math inline">\(\textbf{X}(t_s) := \langle x(t_s), y(t_s), z(t_s)\rangle \cdot \textbf{P}_2\boldsymbol\Lambda_2\)</span>, where <span class="math display">\[
\textbf{P}_2 = \begin{bmatrix}
 0    &amp;  0.87 &amp; -0.50 \\
-1    &amp;  0    &amp;  0    \\
 0    &amp;  0.50 &amp;  0.87
\end{bmatrix}
\]</span> is the orthogonal rotation matrix for a yaw, pitch and roll degree change of <span class="math inline">\(\langle 90^{\circ}, 0^{\circ}, -30^{\circ} \rangle\)</span>, and <span class="math inline">\(\boldsymbol\Lambda_2 = \text{diag}(0.25, 0.1, 0.75)\)</span> is a diagonal scaling matrix.</p></li>
</ul>
<p>These rotation matrices <span class="math inline">\(\textbf{P}_1\)</span> and <span class="math inline">\(\textbf{P}_2\)</span> turn the states in three-dimensional space so that the states are at right angles to each other in at least one dimension, and the scaling matrices <span class="math inline">\(\boldsymbol\Lambda_1\)</span> and <span class="math inline">\(\boldsymbol\Lambda_2\)</span> inflate or deflate the process variances along each principal component. The <code>mspProcessData</code> function calls the internal function <code>dataStateSwitch</code> which splits the observations by state and applies the state-specific rotation and scaling through the internal <code>rotateScale3D</code> function.</p>
</div>
</div>
<div id="synthetic-fault-induction" class="section level3">
<h3 class="hasAnchor">
<a href="#synthetic-fault-induction" class="anchor"></a>Synthetic Fault Induction</h3>
<p>Faults can be introduced to single- or multi-state data via the <code>mspProcessData</code> function. The default fault strt index is 8500, or roughly 84% through the 10,080 observation cycle. These faults are added through the internal <code>faultSwitch</code> function.</p>
<ul>
<li><p>Fault 1A is a positive shift to all three features before state rotation: <span class="math inline">\(\textbf{X}^*(t_s) = \textbf{X}(t_s) + 2,\ s \ge 8500\)</span>.</p></li>
<li><p>Fault 1B is a positive shift to the <span class="math inline">\(x\)</span> feature before state rotation: <span class="math inline">\(x^*(t_s) = x(t_s) + 2,\ s \ge 8500\)</span>.</p></li>
<li><p>Fault 1C is a positive shift to the <span class="math inline">\(x\)</span> and <span class="math inline">\(z\)</span> features in State 3 only and <em>after</em> state rotation: <span class="math inline">\(x^*(t_s) = x(t_s) + 2,\ z^*(t_s) = z(t_s) + 2,\ s \ge 8500\)</span>.</p></li>
<li><p>Fault 2A is a positive drift across all the process monitoring features before state rotation: <span class="math inline">\(\textbf{X}^*(t_s) = \textbf{X}(t_s) + (s - 8500)\times 10^{-3}\)</span>, <span class="math inline">\(s &gt; 8500\)</span>.</p></li>
<li><p>Fault 2B is a positive drift across the <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span> process monitoring features before state rotation: <span class="math inline">\(y^*(t_s) = y(t_s) + (s - 8500)\times 10^{-3},\ z^*(t_s) = z(t_s) + (s - 8500)\times 10^{-3}\)</span>, <span class="math inline">\(s &gt; 8500\)</span>.</p></li>
<li><p>Fault 2C is a negative drift in the <span class="math inline">\(y\)</span> process monitoring feature in State 2 only and <em>after</em> state rotation: <span class="math inline">\(y^*(t_s) = y(t_s) - 1.5 \times \frac{s - 8500}{10080 - 8500}\)</span>, for <span class="math inline">\(s &gt; 8500\)</span>.</p></li>
<li><p>Fault 3A is an amplification of the underlying latent variable <span class="math inline">\(t\)</span> for all features. The maximum latent drift of this fault will be 5 + 1: <span class="math inline">\(\textbf{X}^*(t_s) = \textbf{X}(t_s^*),\ s &gt; 8500\)</span>, where <span class="math inline">\(t_s^* = \left[\frac{5(s - 8500)}{\omega - 8500} + 1\right]t_s\)</span>.</p></li>
<li><p>Fault 3B is a mutation of the underlying latent variable <span class="math inline">\(t\)</span> for the <span class="math inline">\(z\)</span> feature: <span class="math inline">\(z^*(t_s) = z(\log t_s^*)\)</span>, <span class="math inline">\(s \ge 8500\)</span>. This fault will dampen the underlying latent effect for <span class="math inline">\(z\)</span> if <span class="math inline">\(t_s &gt; 1\)</span> and amplify this effect if <span class="math inline">\(t_s &lt; 1\)</span>.</p></li>
<li><p>Fault 3C is a polynomial mutation of the error for the <span class="math inline">\(y\)</span> feature in State 2 only and <em>after</em> state rotation: <span class="math inline">\(y^*(t_s) = y(t_s) + 2 * \textbf{e}_3(s) - 0.25\)</span>, for <span class="math inline">\(s &gt; 8500\)</span>.</p></li>
</ul>
</div>
<div id="putting-it-all-together" class="section level3">
<h3 class="hasAnchor">
<a href="#putting-it-all-together" class="anchor"></a>Putting it all together…</h3>
<p>The <code>mspProcessData</code> function can generate weeks’ worth of non-linear, non-stationary, autocorrelated, multi-state, multivariate process data useful to test new process monitoring techniques. Users can generate observations under NOC to measure false alarm rates, or induce one of nine pre-built faults to test detection time and consistency with repeated Monte Carlo sampling. We expect this function will generate interesting data useful enough to compare new and improved process monitoring techniques with existing methods.</p>
</div>
</div>
<div id="training-with-msptrain" class="section level2">
<h2 class="hasAnchor">
<a href="#training-with-msptrain" class="anchor"></a>Training with <code>mspTrain</code>
</h2>
<p>The <code>mspTrain</code> function will generate projection matrices and test statistic thresholds from test data matrices.</p>
<div id="the-xts-data-matrix" class="section level3">
<h3 class="hasAnchor">
<a href="#the-xts-data-matrix" class="anchor"></a>The <code>xts</code> Data Matrix</h3>
<p>An <code>xts</code> data matrix is first and foremost a matrix, <em>not</em> a data frame. For users very familiar with data frame manipulation (with <code>dplyr</code> for instance), the slight but profound differences between manipulating matrices and data frames become quickly apparent. Because of the class requirements for matrices, <em>all</em> features must be integer or double objects. The <code>mspTrain</code> function cannot train on character information.</p>
<p>The <code>xts</code> object class stands for <em>extendible time series</em> and comes from the package <code>xts</code>, which is itself built on the package <code>zoo</code>. The date and time information (necessarily as <code>POSIX</code> objects) are stored as the row indices of <code>xts</code> matrices. We recommend the package <code>lubridate</code> for manipulating <code>POSIX</code> objects.</p>
</div>
<div id="the-class-vector" class="section level3">
<h3 class="hasAnchor">
<a href="#the-class-vector" class="anchor"></a>The Class Vector</h3>
<p>When implementing single-state AD-PCA, this class vector simply needs to be a numeric column of the same value. However, for MSAD-PCA, the class vector should be an integer vector of class membership. The <code>mspTrain</code> function will split the observations by the class label, apply single-state AD-PCA to each class, then return the class-specific projection matrices and thresholds. Because of this split-apply-combine strategy, users must ensure that one or more classes are not too “rare” – that is, the class-specific sample size should be sufficiently large to allow for stable covariance matrix inversion. For <span class="math inline">\(p\)</span> features (inlcuding lags), covariance inversion requires a class sample size greater than <span class="math inline">\(p ^ 2 / 2\)</span>. Because of this, pay close attention to model parsimony – don’t block the observations on a factor unless the factor significantly affects the observations’ mean vector or covariance matrix.</p>
</div>
<div id="adaptive-and-dynamic-modelling" class="section level3">
<h3 class="hasAnchor">
<a href="#adaptive-and-dynamic-modelling" class="anchor"></a>Adaptive and Dynamic Modelling</h3>
<p>Because of the non-linear, non-stationary, and autocorrelated nature of some process monitoring applications, the <code>mspTrain</code> function allows users to include lags of all feature variables and also to update the training window over time. Including lags of the features in the data matrix can significantly reduce the negative effects of autocorrelation. Re-estimating the projection matrix and test statistic thresholds at pre-specified time intervals reduces the negative effects of non-linearity and non-stationarity in the observations.</p>
<p>The idea is to divide a non-linear and non-stationary process along some boundaries (every day, for instance), and then the process becomes locally linear and stationary within the window. As time progresses, the oldest observations are “forgotten” and the newest observations are “learned”, which causes the projection and NOC thresholds to update over time.</p>
</div>
<div id="model-training" class="section level3">
<h3 class="hasAnchor">
<a href="#model-training" class="anchor"></a>Model Training</h3>
<p>After the observations have been split by class, the <code>mspTrain</code> function will call the internal function <code>processMonitor</code>, which in turn calls the internal function <code>faultFilter</code>. This function will calculate a linear projection matrix of the data by taking the PCA of the training data matrix. The observations will then be projected linearly into a reduced-feature subspace which preserves a chosen proportion of the energy of the training data, where the energy of a matrix is the sum of eigenvalues of that matrix. The default proportion is 90%. This projection is calculated by the internal <code>pca</code> function.</p>
<p>Furthermore, non-parametric threshold values are calculated for the two process monitoring statistics – <em>Squared Prediction Error</em> and <em>Hotelling’s <span class="math inline">\(T^2\)</span></em>. These monitoring statistics are described in the motivating paper. These threshold values are found in the internal <code>threshold</code> function, and passed through the function pipe to be returned by <code>mspTrain</code>. The <span class="math inline">\(\alpha\)</span>-level of the nonparametric threshold is controlled by the user, and its default value is 0.001.</p>
<p>Finally, the <code>mspTrain</code> function will remove any observation which would cause an alarm from the training data set. The alarm free observations will be returned in one <code>xts</code> matrix, while the alarmed observations will be returned by another. When training your process monitor, pay attention to the observations flagged as alarms. The proportion of observations flagged as faults may be higher than the <span class="math inline">\(\alpha\)</span>-level specified, so some tuning may be necessary.</p>
</div>
</div>
<div id="monitoring-incoming-observations-with-mspmonitor" class="section level2">
<h2 class="hasAnchor">
<a href="#monitoring-incoming-observations-with-mspmonitor" class="anchor"></a>Monitoring Incoming Observations with <code>mspMonitor</code>
</h2>
<p>After training the model with <code>mspTrain</code>, the projection matrices and non-parametric monitoring statistic thresholds can be used to flag incoming observations. This function can check every observation in a test matrix (useful when analyzing past data), but was instead designed to test a single incoming observation at a time via a script or batch file. To this end, the <code>mspMonitor</code> function projects a single observation with the class projection matrices returned by <code>mspTrain</code> and checks the observation’s SPE and <span class="math inline">\(T^2\)</span> statistics against the thresholds returned by <code>mspTrain</code>. The <code>mspMonitor</code> will then append the monitoring statistic values, and indicators if these values exceed normal thresholds, to the end of the observation row. This new appended observation will be passed to the <code>mspWarning</code> function.</p>
</div>
<div id="issue-a-warning-with-mspwarning" class="section level2">
<h2 class="hasAnchor">
<a href="#issue-a-warning-with-mspwarning" class="anchor"></a>Issue a Warning with <code>mspWarning</code>
</h2>
<p>If an observation returned by the <code>mspMonitor</code> function has positive statistic indicator values for either the SPE or <span class="math inline">\(T^2\)</span> monitoring statistics, then the <code>mspWarning</code> function will query the last set <span class="math inline">\(r\)</span> observations for other flags. If all <span class="math inline">\(r\)</span> observations are positive for anomalies, then the <code>mspWarning</code> function will issue an alarm. This is the parameter “faultsToTriggerAlarm”, and it defaults to 5. However, this default value depends heavily on the scale of the data: for continuous observations aggregated and recorded every five seconds, the number of sequential faults necessary to trigger an alarm should be very high, perhaps even 50 or more. For observations aggregated to the 10-minute-scale, only three sequential faults may be necessary.</p>
<p>In future updates of this package, this function will also have an option to issue an alarm if a critical mass of non-sequential alarms is reached in a set period of observations. This modification may be necessary if the observation level becomes more fine than the 1-minute-level. Additionally, this function will also be equipped to take in a cell phone number and service provider and issue an alarm via SMS through email.</p>
<p><br><br></p>
</div>
</div>
<div id="example-simulation-workflow" class="section level1">
<h1 class="hasAnchor">
<a href="#example-simulation-workflow" class="anchor"></a>Example Simulation Workflow</h1>
<p>This section provides a fully-commented code walkthrough for the main <code>msp</code> functions in the <code>mvMonitoring</code> package.</p>
<div id="generating-synthetic-data" class="section level2">
<h2 class="hasAnchor">
<a href="#generating-synthetic-data" class="anchor"></a>Generating Synthetic Data</h2>
<p>First begin by generating multi-state data from a fault scenario. This code will yield observations under Fault 2A, as described the Synthetic Fault Induction section. We choose the default options for the period length (7 days * 24 hours * 60 minutes = 10,080 observations), the starting index of the fault (8500 out of 10080), and the time stamp for beggining the data is 16 May of 2016 at 10:00AM (my wedding anniversary). As we can see from the <code>str()</code> function, we have an <code>xts</code> matrix with 10080 rows and four columns (the state indicator and the three features).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(mvMonitoring)
fault1A_xts &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mspProcessData.html">mspProcessData</a></span>(<span class="dt">faults =</span> <span class="st">"A1"</span>,
                              <span class="dt">period =</span> <span class="dv">7</span> <span class="op">*</span><span class="st"> </span><span class="dv">24</span> <span class="op">*</span><span class="st"> </span><span class="dv">60</span>,
                              <span class="dt">faultStartIndex =</span> <span class="dv">8500</span>,
                              <span class="dt">startTime =</span> <span class="st">"2015-05-16 10:00:00 CST"</span>)

<span class="kw">str</span>(fault1A_xts)</code></pre></div>
<pre><code>## An 'xts' object on 2015-05-16 10:00:00/2015-05-23 09:59:00 containing:
##   Data: num [1:10080, 1:4] 1 1 1 1 1 1 1 1 1 1 ...
##  - attr(*, "dimnames")=List of 2
##   ..$ : NULL
##   ..$ : chr [1:4] "state" "x" "y" "z"
##   Indexed by objects of class: [POSIXct,POSIXt] TZ: 
##   xts Attributes:  
##  NULL</code></pre>
</div>
<div id="train-the-fault-detection-threshold" class="section level2">
<h2 class="hasAnchor">
<a href="#train-the-fault-detection-threshold" class="anchor"></a>Train the Fault Detection Threshold</h2>
<p>Now that these observations are generated and stored in memory, the <code>mspTrain</code> function can train the MSAD-PCA model. The last 1620 observations (27 hours’ worth) will be saved for testing. The <code>mspTrain</code> function takes in the training data set partitioned between the observation and the label column. If this function errors, make sure the label column is not included in the data matrix – this will cause a singularity in the data. The function will 1. Train on the first three days’ worth of observations, as set by <code>trainObs</code>. 1. Scan the fourth day for anomalies, as set by <code>updateFreq</code>. 1. Remove any alarmed observations. 1. “Forget” the first day’s observations. 1. “Learn” the non-alarmed observations from the fourth day. 1. Retrain and repeat until the end of the data matrix</p>
<p>Furthermore, the <code>Dynamic = TRUE</code> option means that the <code>mspTrain</code> function will include the lags specified by the <code>lagsIncluded</code> argument. Finally, the number of sequential anomalous observations necessary to raise an alarm is set at 5 by the <code>faultsToTriggerAlarm</code> argument. These last three arguments are set to their defaults.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">train1A_xts &lt;-<span class="st"> </span>fault1A_xts[<span class="dv">1</span><span class="op">:</span><span class="dv">8461</span>,]
<span class="co"># This function will run in 13 seconds on the author's machine.</span>
train1A_ls &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mspTrain.html">mspTrain</a></span>(<span class="dt">data =</span> train1A_xts[,<span class="op">-</span><span class="dv">1</span>],
                       <span class="dt">labelVector =</span> train1A_xts[,<span class="dv">1</span>],
                       <span class="dt">trainObs =</span> <span class="dv">3</span> <span class="op">*</span><span class="st"> </span><span class="dv">24</span> <span class="op">*</span><span class="st"> </span><span class="dv">60</span>,
                       <span class="dt">updateFreq =</span> <span class="dv">1</span> <span class="op">*</span><span class="st"> </span><span class="dv">24</span> <span class="op">*</span><span class="st"> </span><span class="dv">60</span>,
                       <span class="dt">Dynamic =</span> <span class="ot">TRUE</span>,
                       <span class="dt">lagsIncluded =</span> <span class="dv">0</span><span class="op">:</span><span class="dv">1</span>,
                       <span class="dt">faultsToTriggerAlarm =</span> <span class="dv">5</span>)</code></pre></div>
<p>The <code>mspTrain</code> function returns a list of four objects:</p>
<ul>
<li>
<code>FaultChecks</code>: An <code>xts</code> matrix of monitoring statistics and associated indicators for all observations after the burn-in of <code>trainObs</code>. It will have 10080 - <code>trainObs</code> number of rows and five columns:
<ul>
<li>
<code>SPE</code>: the SPE statistic for each observation.</li>
<li>
<code>SPE_Flag</code>: an indicator showing if the SPE statistic for that observation is beyond the calculated threshold; 0 is normal, 1 is flagged.</li>
<li>
<code>T2</code>: the <span class="math inline">\(T^2\)</span> statistic for each observation.</li>
<li>
<code>T2_Flag</code>: an indicator showing if the <span class="math inline">\(T^2\)</span> statistic for that observation is beyond the calculated threshold; 0 is normal, 1 is flagged.</li>
<li>
<code>Alarm</code>: an indicator showing if the observation is in a sequence of flagged observations; 0 is normal, 1 is alarmed.</li>
</ul>
</li>
<li>
<code>Non_Alarmed_Obs</code>: An <code>xts</code> matrix will all observations with an alarm code of 0 from <code>FaultChecks</code>. Of note, this matrix contains the data, while the <code>FaultChecks</code> matrix only contains the monitoring statistics and indicators.</li>
<li>
<code>Alarms</code>: An <code>xts</code> matrix of all the observations removed from the training data matrix.</li>
<li>
<code>TrainingSpecs</code>: a list with length equal to the number of classes – in this case 3. For each class, this list contains a list of six objects:
<ul>
<li>
<code>SPE_Threshold</code>: a named numeric scalar of the 1 - <span class="math inline">\(\alpha\)</span> percentile of the non-parametric estimate of the SPE statistic density.</li>
<li>
<code>T2_Threshold</code>: a named numeric scalar of the 1 - <span class="math inline">\(\alpha\)</span> percentile of the non-parametric estimate of the <span class="math inline">\(T^2\)</span> statistic density.</li>
<li>
<code>projectionMatrix</code>: The <span class="math inline">\(p \times q\)</span> matrix of eigenvectors necessary to project a <span class="math inline">\(p\)</span>-dimensional observation to <span class="math inline">\(q\)</span> dimensions. This is necessary to reduce the dimension of any test observation, and is used in calculating the SPE statistic for test observations.</li>
<li>
<code>LambdaInv</code>: The inverse of the diagonal <span class="math inline">\(q \times q\)</span> matrix of eigenvalues. This matrix is used to calculate the <span class="math inline">\(T^2\)</span> statistic for test observations.</li>
<li>
<code>muTrain</code>: The mean vector of the training observations. This is used to center the test observations on the training mean.</li>
<li>
<code>RootPrecisTrain</code>: The <span class="math inline">\(p \times p\)</span> diagonal matrix of the inverse square roots of the feature variances. This is used to scale the test observations into the training scale.</li>
</ul>
</li>
</ul>
</div>
<div id="test-new-observations-for-anomalies" class="section level2">
<h2 class="hasAnchor">
<a href="#test-new-observations-for-anomalies" class="anchor"></a>Test New Observations for Anomalies</h2>
<p>The training data summary was given by <code>mspTrain</code>, so this information can now be used to monitor incoming observations for system faults.</p>
<div id="adding-lagged-features" class="section level3">
<h3 class="hasAnchor">
<a href="#adding-lagged-features" class="anchor"></a>Adding Lagged Features</h3>
<p>First, concatenate the last given observation from the training set as “row 0” of the test data set. This will enable <code>mspMonitor</code> to include lag-1 features. Similarly, one would include the last <span class="math inline">\(k\)</span> observations of the training set should the process dictate the need for any lag-<span class="math inline">\(k\)</span> features. Because the Fault Start Index was set to 8500, this testing window will show the change point between observations generated under normal conditions and those generated under a fault state.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(xts)
test1A_xts &lt;-<span class="st"> </span>fault1A_xts[<span class="dv">8460</span><span class="op">:</span><span class="dv">8520</span>, <span class="op">-</span><span class="dv">1</span>]
lagTest1A_xts &lt;-<span class="st"> </span><span class="kw">lag.xts</span>(test1A_xts, <span class="dv">0</span><span class="op">:</span><span class="dv">1</span>)
lagTest1A_xts &lt;-<span class="st"> </span><span class="kw">cbind</span>(fault1A_xts[<span class="dv">8461</span><span class="op">:</span><span class="dv">8520</span>,<span class="dv">1</span>],
                       lagTest1A_xts[<span class="op">-</span><span class="dv">1</span>,])
<span class="kw">head</span>(lagTest1A_xts)</code></pre></div>
<pre><code>##                     state         x         y         z       x.1
## 2015-05-22 07:00:00     1 0.8952197 -1.762959 1.3973496 0.4321741
## 2015-05-22 07:01:00     1 0.5192872 -1.513536 0.8545564 0.8952197
## 2015-05-22 07:02:00     1 0.7102784 -1.718552 1.0048432 0.5192872
## 2015-05-22 07:03:00     1 0.7297041 -1.611477 0.7835430 0.7102784
## 2015-05-22 07:04:00     1 0.6061820 -1.525118 0.9042388 0.7297041
## 2015-05-22 07:05:00     1 0.5328942 -1.366411 0.7420912 0.6061820
##                            y.1       z.1
## 2015-05-22 07:00:00  0.1327537 0.5059442
## 2015-05-22 07:01:00 -1.7629587 1.3973496
## 2015-05-22 07:02:00 -1.5135355 0.8545564
## 2015-05-22 07:03:00 -1.7185519 1.0048432
## 2015-05-22 07:04:00 -1.6114769 0.7835430
## 2015-05-22 07:05:00 -1.5251179 0.9042388</code></pre>
</div>
<div id="monitoring-the-test-data" class="section level3">
<h3 class="hasAnchor">
<a href="#monitoring-the-test-data" class="anchor"></a>Monitoring the Test Data</h3>
<p>With the lagged test observations in the working environment, the <code>mspMonitor</code> function can be applied. This function (similarly to <code>mspTrain</code>) takes in the label information as a separate argument from the input data. Further, the <code>mspMonitor</code> function takes in the <code>TrainingSpecs</code> object returned in the results list from <code>mspTrain</code>. Notice that the first six rows of the monitor matrix are the exact same as the first six rows of the lagged test matrix, except that the rows of the monitor matrix have the monitoring statistic and corresponding indicator columns appended.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">monitor1A_xts &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mspMonitor.html">mspMonitor</a></span>(<span class="dt">observations =</span> lagTest1A_xts[,<span class="op">-</span><span class="dv">1</span>],
                            <span class="dt">labelVector =</span> lagTest1A_xts[,<span class="dv">1</span>],
                            <span class="dt">trainingSummary =</span> train1A_ls<span class="op">$</span>TrainingSpecs)
<span class="kw">head</span>(monitor1A_xts)</code></pre></div>
<pre><code>##                             x         y         z       x.1        y.1
## 2015-05-22 07:00:00 0.8952197 -1.762959 1.3973496 0.4321741  0.1327537
## 2015-05-22 07:01:00 0.5192872 -1.513536 0.8545564 0.8952197 -1.7629587
## 2015-05-22 07:02:00 0.7102784 -1.718552 1.0048432 0.5192872 -1.5135355
## 2015-05-22 07:03:00 0.7297041 -1.611477 0.7835430 0.7102784 -1.7185519
## 2015-05-22 07:04:00 0.6061820 -1.525118 0.9042388 0.7297041 -1.6114769
## 2015-05-22 07:05:00 0.5328942 -1.366411 0.7420912 0.6061820 -1.5251179
##                           z.1       SPE SPE_Flag        T2 T2_Flag Alarm
## 2015-05-22 07:00:00 0.5059442 0.8526590        0 30.325145       0    NA
## 2015-05-22 07:01:00 1.3973496 0.8828911        0  4.451750       0    NA
## 2015-05-22 07:02:00 0.8545564 0.1655790        0  3.942880       0    NA
## 2015-05-22 07:03:00 1.0048432 0.2496153        0  4.019013       0    NA
## 2015-05-22 07:04:00 0.7835430 0.3408599        0  4.468941       0    NA
## 2015-05-22 07:05:00 0.9042388 0.7839264        0  5.427270       0    NA</code></pre>
</div>
</div>
<div id="warn-operators-during-alarms" class="section level2">
<h2 class="hasAnchor">
<a href="#warn-operators-during-alarms" class="anchor"></a>Warn Operators during Alarms</h2>
<p>Note that all <code>Alarm</code> codes in the monitor matrix above are recorded with <code>NA</code> values. This is because the <code>mspMonitor</code> function does not check the sequential flag conditions of the monitor matrix. This is the responsibility of the <code>mspWarning</code> function. Because the <code>mspWarning</code> function is designed to test one incoming observation at a time through a script or batch file, the following example is designed to mimic the behavior of the <code>mspWarning</code> function as each new observation comes online.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">alarm1A_xts &lt;-<span class="st"> </span>monitor1A_xts
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(alarm1A_xts)){
  <span class="cf">if</span>(i <span class="op">&lt;</span><span class="st"> </span>(<span class="dv">5</span> <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)){
    alarm1A_xts[<span class="dv">1</span><span class="op">:</span>i,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mspWarning.html">mspWarning</a></span>(alarm1A_xts[<span class="dv">1</span><span class="op">:</span>i,])
  }<span class="cf">else</span>{
    alarm1A_xts[(i <span class="op">-</span><span class="st"> </span><span class="dv">5</span>)<span class="op">:</span>i,] &lt;-<span class="st"> </span><span class="kw"><a href="../reference/mspWarning.html">mspWarning</a></span>(alarm1A_xts[(i <span class="op">-</span><span class="st"> </span><span class="dv">5</span>)<span class="op">:</span>i,])
  }
}</code></pre></div>
<p>The fault was introduced at index 8500, which corresponds to about 40 minutes into the test hour.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(alarm1A_xts[, <span class="kw">ncol</span>(alarm1A_xts)],
     <span class="dt">main =</span> <span class="st">"Alarm Codes for Test Data"</span>)</code></pre></div>
<p><img src="MVSPC-Workflow_files/figure-html/unnamed-chunk-6-1.png" width="100%"> The alarm codes are</p>
<ul>
<li>“0”: No alarm.</li>
<li>“1”: Hotelling’s <span class="math inline">\(T^2\)</span> alarm.</li>
<li>“2”: Squared Prediction Error alarm.</li>
<li>“3”: Both alarms.</li>
</ul>
<p><br><br></p>
</div>
</div>
<div id="conclusion" class="section level1">
<h1 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h1>
<p>We have supplied our motivation for this package, and we have discussed implementing a multivariate process monitoring scheme with this package using the example of a decentralized WWT plant in Golden, CO. We believe that this software will provide system engineers with the tools necessary to quickly and accurately detect abnormalities in multivariate, autocorrelated, non-stationary, non-linear, and multi-state water treatment systems. Further, we have given a synthetic example showing how the functions within this package would be implemented and tuned in practice.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction </a></li>
      <li>
<a href="#motivation">Motivation </a><ul class="nav nav-pills nav-stacked">
<li><a href="#why-use-mvmonitoring">Why use <code>mvMonitoring</code></a></li>
      <li><a href="#multi--or-single-state-ad-pca">Multi- or Single-State AD-PCA</a></li>
      </ul>
</li>
      <li>
<a href="#the-msp-functions">The <code>msp</code> Functions</a><ul class="nav nav-pills nav-stacked">
<li><a href="#simulating-data-with-mspprocessdata">Simulating Data with <code>mspProcessData</code></a></li>
      <li><a href="#training-with-msptrain">Training with <code>mspTrain</code></a></li>
      <li><a href="#monitoring-incoming-observations-with-mspmonitor">Monitoring Incoming Observations with <code>mspMonitor</code></a></li>
      <li><a href="#issue-a-warning-with-mspwarning">Issue a Warning with <code>mspWarning</code></a></li>
      </ul>
</li>
      <li>
<a href="#example-simulation-workflow">Example Simulation Workflow</a><ul class="nav nav-pills nav-stacked">
<li><a href="#generating-synthetic-data">Generating Synthetic Data</a></li>
      <li><a href="#train-the-fault-detection-threshold">Train the Fault Detection Threshold</a></li>
      <li><a href="#test-new-observations-for-anomalies">Test New Observations for Anomalies</a></li>
      <li><a href="#warn-operators-during-alarms">Warn Operators during Alarms</a></li>
      </ul>
</li>
      <li><a href="#conclusion">Conclusion</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by <a href="https://github.com/melissanjohnson">Melissa Johnson</a>, <a href="https://github.com/gabrielodom">Gabriel Odom</a>, <a href="http://benbarnard.bearstatistics.com">Ben Barnard</a>, Karen Kazor, Amanda Hering.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
